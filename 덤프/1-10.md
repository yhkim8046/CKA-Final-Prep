Q1
문제:
echo "hello world" 출력 후 종료하는 Pod 생성, 완료되면 자동 삭제

해법:
kubectl run hello --image=busybox --restart=Never --rm -it -- /bin/sh -c 'echo hello world'

Q2
문제:
Pod foo 로그에서 error unable-to-access-website 라인만 추출하여 /opt/KULM00201/foo에 저장

해법:
kubectl logs foo | grep "unable-to-access-website" > /opt/KULM00201/foo

Q3
문제:
Pod 이름: mongo
이미지: mongo
네임스페이스: my-website

해법:

kubectl create ns my-website
kubectl run mongo --image=mongo -n my-website --restart=Never

Q4
문제:
Deployment 생성
이름: nginx-app
이미지: nginx:1.11.10-alpine
replicas: 3
rolling update → 1.11.13-alpine
rollback → 1.11.10-alpine

해법:

kubectl create deploy nginx-app --image=nginx:1.11.10-alpine --replicas=3
kubectl set image deploy/nginx-app nginx=nginx:1.11.13-alpine
kubectl rollout undo deploy/nginx-app

Q5

문제:
Pod nginx-dev, nginx-prod 삭제

해법:

kubectl delete pod nginx-dev nginx-prod

Q6

문제:
Node ek8s-node-1을 Unavailable로 설정하고, 모든 Pod 재스케줄링

해법:

kubectl cordon ek8s-node-1
kubectl drain ek8s-node-1 --ignore-daemonsets --delete-emptydir-data

Q7

문제:
PersistentVolume 생성

이름: app-data

용량: 2Gi

AccessMode: ReadWriteMany

hostPath: /srv/app-data

해법 (pv-app-data.yaml):

apiVersion: v1
kind: PersistentVolume
metadata:
  name: app-data
spec:
  capacity:
    storage: 2Gi
  accessModes:
  - ReadWriteMany
  storageClassName: shared
  hostPath:
    path: "/srv/app-data"

kubectl apply -f pv-app-data.yaml

Q8

문제:
모든 PV를 용량순으로 정렬, /opt/KUCC00102/volume_list에 저장

해법:

kubectl get pv --sort-by=.spec.capacity.storage -o wide > /opt/KUCC00102/volume_list

Q9

문제:
Pod 생성
이름: non-persistent-redis
이미지: redis
Volume 이름: cache-control
Mount: /data/redis
네임스페이스: staging
emptyDir 사용

해법 (non-persistent-redis.yaml):

apiVersion: v1
kind: Pod
metadata:
  name: non-persistent-redis
  namespace: staging
spec:
  containers:
  - name: redis
    image: redis
    volumeMounts:
    - name: cache-control
      mountPath: /data/redis
  volumes:
  - name: cache-control
    emptyDir: {}

kubectl apply -f non-persistent-redis.yaml

Q10a

문제:
Secret + Pod 생성

Secret 이름: super-secret, password=bob

Pod1: pod-secrets-via-file → redis, Secret을 /secrets에 마운트

Pod2: pod-secrets-via-env → redis, password를 CONFIDENTIAL 환경변수로 노출

해법:

kubectl create secret generic super-secret --from-literal=password=bob

# Pod1
apiVersion: v1
kind: Pod
metadata:
  name: pod-secrets-via-file
spec:
  containers:
  - name: redis
    image: redis
    volumeMounts:
    - name: secret-vol
      mountPath: /secrets
      readOnly: true
  volumes:
  - name: secret-vol
    secret:
      secretName: super-secret

# Pod2
apiVersion: v1
kind: Pod
metadata:
  name: pod-secrets-via-env
spec:
  containers:
  - name: redis
    image: redis
    env:
    - name: CONFIDENTIAL
      valueFrom:
        secretKeyRef:
          name: super-secret
          key: password

Q10b

문제:
nginx Pod 2개 생성

하나는 label=env=prod

다른 하나는 label=env=dev

해법:

kubectl run nginx-prod --image=nginx --labels=env=prod --restart=Never
kubectl run nginx-dev --image=nginx --labels=env=dev --restart=Never

kubectl get pods --show-labels
kubectl get pods -l env=prod
kubectl get pods -l env=dev
